"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { subscriptions } = context;
        const config = coc_nvim_1.workspace.getConfiguration().get('css', {});
        if (!config.enable)
            return;
        const file = context.asAbsolutePath('./lib/server/cssServerMain.js');
        const selector = ['css', 'less', 'scss', 'wxss'];
        let serverOptions = {
            module: file,
            args: ['--node-ipc'],
            transport: coc_nvim_1.TransportKind.ipc,
            options: {
                cwd: coc_nvim_1.workspace.root,
                execArgv: config.execArgv || []
            }
        };
        let clientOptions = {
            documentSelector: selector,
            synchronize: {
                configurationSection: ['css', 'less', 'scss', 'wxss']
            },
            outputChannelName: 'css',
            initializationOptions: config.initializationOptions || {},
            middleware: {
                provideCompletionItem: (document, position, context, token, next) => {
                    return Promise.resolve(next(document, position, context, token)).then((res) => {
                        let doc = coc_nvim_1.workspace.getDocument(document.uri);
                        if (!doc)
                            return [];
                        let items = res.hasOwnProperty('isIncomplete') ? res.items : res;
                        let pre = doc.getline(position.line).slice(0, position.character);
                        // searching for class name
                        if (/(^|\s)\.\w*$/.test(pre)) {
                            items = items.filter(o => o.label.startsWith('.'));
                            items.forEach(fixItem);
                        }
                        if (context.triggerCharacter == ':'
                            || /\:\w*$/.test(pre)) {
                            items = items.filter(o => o.label.startsWith(':'));
                            items.forEach(fixItem);
                        }
                        return items;
                    });
                }
            }
        };
        let client = new coc_nvim_1.LanguageClient('css', 'Css language server', serverOptions, clientOptions);
        subscriptions.push(coc_nvim_1.services.registLanguageClient(client));
    });
}
exports.activate = activate;
function fixItem(item) {
    item.insertText = item.label.slice(1); // tslint:disable-line
    item.textEdit = null;
    item.insertTextFormat = vscode_languageserver_protocol_1.InsertTextFormat.PlainText;
}
//# sourceMappingURL=index.js.map